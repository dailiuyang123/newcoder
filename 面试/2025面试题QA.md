# 2025年Java常见面试题网页总结


## 二、核心面试题要点
### （一）数据库相关
1. **事务特性**：原子性、一致性、隔离性、持久性（ACID）
2. **防SQL注入措施**：使用`#`而非`$`符号；对入参校验；使用存储过程；执行预处理语句和参数化查询；遵循最低权限原则
3. **三范式**：原子性、唯一性、冗余性
4. **SQL优化手段**：创建合适索引（唯一索引、普通索引、复合索引）；SQL语句优化（不在索引列用函数、where语句不用操作符/null判断/or连接、模糊查询`%`放后面）


### （二）微服务相关
1. **拆分原则**：从业务、技术、组织结构三个维度出发
    - 业务：按DDD领域驱动设计，遵循持续演进原则（先粗后细迭代）
    - 技术：遵循单一责任、闭包、服务自治、高内聚低耦合、数据隔离原则；性能要求高/压力大的服务单拆（如读写分离）；成熟少改服务拆为稳定服务，迭代快服务拆为变动服务；按安全隔离（对外/对内）拆分；沉淀重复功能为通用服务；不同语言异构成独立服务
    - 组织：依据康威定律，结合公司组织结构设计
2. **拆分合理性验证**：从业务（满足当前及未来发展）、技术（性能、安全性、部署维护成本）、组织（促进团队协作沟通）评估；拆分与合并需持续演进、迭代优化


### （三）Kafka相关
1. **高吞吐原因**：分区分段+并行处理（topic分多分区存不同服务器，数据分段加索引，生产者消费者并行）；批量读写与压缩；基于系统page Cache（读写内存）+零copy技术（数据直拷到nic缓冲区）；顺序写磁盘（减少寻址时间，缺点是不能删数据）
2. **避免消息丢失措施**：生产者用ack机制（0-发完即成功，1-Leader副本接收成功，-1-Leader与follower均写入成功）；broker设多分区副本+刷盘频率；消费者关闭自动提交offset（消费完成后提交），支持幂等消费


### （四）Java性能与JVM相关
1. **CPU过高排查步骤**：用jps查看本机线程信息；top命令找高占用进程PID；top -hp PID查进程下线程ID并转16进制TID；jstack打印线程堆栈（jstack PID生成快照，jstack pid | grep tid -A 60找对应堆栈）；jstat监控JVM内存（jstat -gc pid 3000，若FGC频率高用jstack+jmap分析堆内存）；jmap生成内存快照（jmap -dump:format=b,file=heapdump.phrof pid，用jprofiler等工具分析）
2. **JVM内存**：堆、方法区为线程共享（垃圾回收主要针对堆，堆分新生代-eden/from survivor/to survivor、老年代）；虚拟机栈、本地方法栈、程序计数器为线程独有；方法区在JDK8后由元空间替代（元空间存本地内存，可动态调整大小，减少OOM，原永久代有内存溢出、GC效率低、无法动态调整大小等问题）


### （五）并发与线程相关
1. **synchronized与Lock区别**：


| 特性         | synchronized                          | Lock                                      |
|--------------|---------------------------------------|-------------------------------------------|
| 实现层面     | Java关键字，JVM隐式锁                 | Java类（如`ReentrantLock`），显式锁       |
| 锁释放       | 自动释放（代码块结束/异常时）         | 需手动释放（需在`finally`块中调用`unlock()`） |
| 锁特性       | 可重入、不可中断、默认非公平锁        | 可重入、可中断（`lockInterruptibly()`）、可设置公平/非公平锁 |
| 性能         | 低竞争场景下性能优秀（悲观锁，排它锁，依赖线程等待机制） | 高并发场景下性能更优（基于AQS+CAS实现，属于乐观锁思路） |
| 其他         | 支持偏向锁、轻量级锁、重量级锁（JVM自动升级） | 基于AQS（AbstractQueuedSynchronizer）维护锁状态与FIFO等待队列，CAS为硬件级原子操作 |
2. **线程池类型与配置**：
    - 预设线程池：FixedThreadPool（固定大小，如查数据库，配阻塞队列）、SingleThreadExecutor（单线程，如文件读写，配阻塞队列）、CachedThreadPool（动态大小）、ScheduledThreadPool（定时执行）
    - 自定义配置：CPU密集型（如视频解码、数据加密）核心/最大线程数=CPU线程数+1（减少上下文切换，应对线程阻塞）；IO密集型核心线程数=CPU*2，最大线程数=CPU*2~3


### （六）其他技术点
1. **设计模式**：常用单例、工厂、适配器、观察者、建造者、策略、责任链、代理模式
2. **thrift**：支持二进制/文本传输协议，支持基本类型、结构体、集合、异常类型、服务类型，底层为RPC远程调用，需定义协议格式
3. **MySQL索引**：基于B+树存储，叶子结点存key+value，其他节点存key；叶子结点有相邻引用，数据增删改时会重平衡
4. **char与varchar区别**：char为固定长度（适合手机号、身份证号）；varchar为可变长度（适合姓名、地址，多1位存长度）
5. **并发编程三要素**：原子性、有序性、可见性

### 快速失败（fail - fast）和安全失败（fail - safe）是两种不同的迭代器设计策略，主要用于处理集合在遍历过程中被修改的场景，其区别如下：
- **对修改的响应**：
   - **快速失败**：当集合在遍历过程中被修改，迭代器会立即抛出`ConcurrentModificationException`异常，强制终止遍历。
   - **安全失败**：即使集合在遍历过程中被修改，迭代器也不会抛出异常，而是基于原始数据或快照继续遍历。
- **数据一致性**：
   - **快速失败**：严格反映最新数据，若遍历中集合被修改，会因抛出异常而无法完成遍历，但能保证数据一致性状态是最新的（若不抛出异常则为最新）。
   - **安全失败**：可能基于快照遍历，不反映最新修改，牺牲了数据一致性以换取安全性，遍历的结果可能与当前集合的实际状态不一致。
- **适用场景**：
   - **快速失败**：更适合单线程环境，可快速检测代码逻辑错误，如开发阶段调试集合的非法修改。在多线程环境下无法可靠检测并发修改，可能出现误判或漏判情况。
   - **安全失败**：适用于多线程环境，通过快照或弱一致性设计支持并发操作，常用于实时数据处理、消息队列等对稳定性要求较高的场景。
- **性能开销**：
   - **快速失败**：通常性能开销较低，主要是通过维护一个修改计数器（`modCount`），每次遍历检查其是否与初始值一致，操作简单。
   - **安全失败**：由于需要维护集合的副本或快照，性能开销相对较高。
- **典型集合**：
   - **快速失败**：常见于`ArrayList`、`HashMap`等非线程安全集合。
   - **安全失败**：常见于`ConcurrentHashMap`、`CopyOnWriteArrayList`等线程安全集合。
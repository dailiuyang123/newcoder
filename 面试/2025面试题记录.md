### 面试资源

- [绘问IT面试题库](https://it.huiwenai.net/pc/group/list?id=1898270441985200129&typeId=1853061632069382145)

- [面试题](https://github.com/huiwenai/interview)
- 

# 华为

### 华为hr资格面试 2025-9-5


### 1.当前AI技术越来成熟，请你谈谈AI对程序员的影响


### 2. 对于AI技术，你是怎么看待的？

### 3. 你认为AI技术对程序员有什么影响？

A：AI技术对程序员的影响呈现出效率提升与职业重构并存的复杂态势，既带来生产力革命，也推动开发者角色向更高维度转型。以下从六个核心维度展开分析：

### 一、开发流程的智能化重构
AI工具已深度渗透编码全流程，实现从“手动编写”到“智能协作”的范式转变。以GitHub Copilot为例，其通过自然语言描述生成代码片段的能力，使基础代码编写时间缩短60%以上。阿里云通义灵码甚至能自主完成需求分析、代码生成、缺陷修复的全链路开发，5分钟即可实现传统程序员一天的工作量。这类工具不仅生成代码框架（如Flask后端路由、HTML页面结构），还能实时检测缩进错误、变量未定义等问题，并提供重构建议。

在测试环节，AI工具可自动生成覆盖3倍于传统方法的测试用例，使企业级项目测试周期缩短30%-50%。Google Gemini Code Assist更支持每月18万次代码补全，并能解释代码时间复杂度、优化异步操作逻辑，这种“编码-测试-优化”的全流程赋能，正在重塑软件开发的效率边界。

### 二、技能需求的结构性升级
程序员的能力图谱正经历三大跃迁：
1. **AI技术栈深度融合**：需掌握机器学习基础（如线性回归、神经网络）以理解AI工具原理，同时熟悉TensorFlow等框架实现模型调优。例如开发图像识别API时，需通过卷积神经网络知识调整参数优化性能。
2. **跨领域知识整合**：医疗软件开发需了解疾病诊断流程，金融AI应用需掌握风险管理知识，这种领域交叉能力成为创新关键。某金融科技企业通过AI处理重复性任务后，工程师转而专注量化模型设计，推动产品迭代效率提升40%。
3. **人机协作范式重构**：Prompt Engineering（提示工程）成为新技能，开发者需设计精准指令引导AI生成符合业务逻辑的代码。例如通过“创建用户登录界面并实现前端验证”的描述，AI可快速生成包含HTML、CSS和JavaScript的完整框架。

### 三、职业发展的两极分化
AI技术正在重塑程序员的职业坐标系：
- **传统岗位需求收缩**：初级程序员面临自动化工具和低代码平台的双重挤压，简单CRUD开发岗位减少30%。Stack Overflow调查显示，仅17%开发者“主要使用AI编写代码”，但46%表示AI处理复杂任务能力“糟糕”，这表明基础编码工作虽被替代，但复杂逻辑设计仍需人类介入。
- **新兴角色崛起**：AI系统开发工程师、算法调优师等岗位需求激增，薪资水平较普通程序员高出50%以上。某互联网企业设立“AI训练师”岗位，通过微调大模型适应量化金融场景，推动产品响应速度提升20%。
- **跨职能转型机遇**：部分开发者转向技术管理或领域专家，例如某医疗软件团队的程序员转型为AI伦理顾问，主导算法公平性审查流程。

### 四、开发者信任与效率的悖论
尽管AI工具使用率达81.4%，但信任度呈现下降趋势：46%开发者不信任AI输出，45%认为调试生成代码耗时更长。这种矛盾源于AI的“黑箱”特性——生成的代码可能存在未处理异常等漏洞，且逻辑可解释性不足。例如某电商项目因AI生成代码未考虑银联异步回调超时机制，导致支付接口故障。

效率层面同样存在“工具陷阱”：虽然AI工具使开发周期缩短70%，但Stack Overflow数据显示，开发者每天搜索答案时间仅从63%降至61%，改善幅度微弱。这表明单纯依赖工具而不优化流程，难以实现生产力质的飞跃。

### 五、行业领域的差异化冲击
不同领域受AI影响程度呈现显著差异：
- **高替代风险领域**：测试工程师（60%重复性操作）、前端开发（40%模板化工作）首当其冲。某互联网公司引入AI测试工具后，测试用例生成效率提升3倍，团队规模缩减25%。
- **中低替代风险领域**：后端开发（复杂状态管理）、算法工程师（模型可解释性需求）仍需人类主导。某金融企业在处理资金清算场景时，坚持人工设计强一致性方案，避免了AI可能引发的事务回滚风险。
- **新兴交叉领域**：量子计算与AI的融合催生新机会，例如量子机器学习可使图像识别准确率提升5%-10%，相关岗位成为稀缺资源。

### 六、应对策略与未来展望
开发者需构建“AI协作型”能力体系：
1. **技术深耕与工具驯化**：在嵌入式开发等领域建立专业壁垒，同时通过AI工具快速验证技术选型。例如某物联网团队利用AI生成硬件驱动代码后，工程师专注传感器融合算法优化，产品功耗降低15%。
2. **软技能强化**：培养需求抽象、伦理判断等不可替代能力。某教育科技企业要求程序员参与用户调研，将“沉浸式学习体验”需求转化为AI+VR应用设计，推动产品获行业创新奖。
3. **持续学习生态构建**：通过Coursera等平台学习量子计算等前沿知识，参与NeurIPS等学术会议追踪技术趋势。某开发者通过学习量子编程语言Q#，成功将AI模型训练效率提升30%。

未来，AI将从“辅助工具”进化为“协同开发者”，但人类的创造力、领域洞察和复杂决策能力仍是核心竞争力。正如蒸汽机时代工匠转向机床操作，AI时代的程序员将从代码执行者升级为技术决策者，在人机协作中定义新的价值坐标。

### 4. 你平时的学习方式


# 震雄集团

### 面试偏向业务与HR，技术比较少

#### 1. 自我介绍

#### 2. 在开发中使用的是什么系统 
- windows
- linux
- mac

#### 3. 有没有使用过工作流引擎

- Flowable
    - 流程定义（BPMN 2.0标准的XML文件）
    - 流程实例
    - 任务
    - 网关（用于控制流程的流转） 
    - 条件表达式（）
    - 边界事件
    - 流程定义
    - 集成到springboot中：POM 依赖坐标
      - flowable-spring-boot-starter 6.7.2

- Activiti

#### 4. 描述一个项目，并给出项目所使用的技术



# 华为OD 2025-9-8

### 一分钟自我介绍

### 问了十几个Java相关面试题

  - 线程和进程的区别？
  > 答案：进程：系统运行的基本单位，进程在运行过程中都是相互独立，但是线程之间运行可以相互影响。
    线程：独立运行的最小单位，一个进程包含多个线程且它们共享同一进程内的系统资源
    进程间通过管道、 共享内存、信号量机制、消息队列通信
  - 介绍一下常见的工厂模式？
    - 简单工厂
    - 工厂方法
    - 抽象工厂
  - 设计模式扩展
    > Spring 常用设计模式 \
    单例模式:bean默认都是单例的 \
    原型模式:指定作用域为prototype \
    工厂模式:BeanFactory \
    模板方法:postProcessBeanFactory,onRefresh,initPropertyValue \
    策略模式:XmlBeanDefinitionReader,PropertiesBeanDefinitionReader \
    观察者模式:listener,event,multicast \
    适配器模式:Adapter \
    装饰者模式:BeanWrapper \
    责任链模式:使用aop的时候会先生成一个拦截器链 \
    代理模式:动态代理
  - spring cloud 常见的组件？
    - 服务注册用发现
      - Nacos(功能全面)
      - Consul(强一致性)
    - 服务调用组件
      - OpenFeign + Spring Cloud LoadBalancer
    - 网关
      - spring cloud gateway
    - 容错与流量配置
      - Sentinel（高并发）或 Resilience4J（轻量）
    - 配置管理
      - Nacos Config
    - 负载均衡与服务调用
      - OpenFeign + Spring Cloud LoadBalancer
    - 分布式追踪
      - Micrometer Tracing + Zipkin
    - 消息驱动
    - 安全认证
      - Spring Cloud Security + OAuth2/JWT  
    - 分布式事务
      - Seata
        -  AT模式 保证常见关系型数据库分布式事务的一致性
          - AT模式是一种无侵入式的分布式事务模式（本地事务+补偿机制），使用与关系型数据库如（MySql）,核心依赖（undo log）回滚日志和全局锁保持一致（XID）全局事务ID
        - TCC模式 保证常见关系型数据库分布式事务的一致性
        - SAGA模式 保证常见关系型数据库分布式事务的一致性

# 金蝶 2025-9-9

### Spring Cloud 问的很多？
    
- Spring Cloud 常用组件？

    - 服务注册与发现 （open feign (alibaba)   ）

- Spring Cloud 服务间调用使用的是什么组件？
  - open feign + spring cloud load balancer

- 服务间调用如何保证数据安全？
  - ：
  - 
## 消息队列问的很深

## 为什么选择kafka?

## - 请说一下rabbitMQ 中 vhost 的作用？

  >  RabbitMQ 中的 **Virtual Host**（虚拟主机，简称 vhost）是一个非常重要的逻辑隔离机制。你可以把它想象成一台物理服务器（RabbitMQ Broker）里的多个独立「迷你消息服务器」，每个都有自己全套的资源（交换机、队列、绑定关系）和权限体系。

| 作用与场景         | 说明                                                                 | 举例                                     |
| :----------------- | :------------------------------------------------------------------- | :--------------------------------------- |
| **资源隔离**       | 不同vhost间的交换机、队列、消息绝对隔离，无法直接通信。            | `/app1` 的订单队列无法被 `/app2` 消费        |
| **权限控制**       | 用户权限基于vhost分配，实现安全管控。                       | 用户A可管理`/prod`，但只能读`/test`         |
| **多环境支持**     | 同一集群上为不同环境（开发、测试、生产）创建独立的vhost。                 | `/dev`, `/test`, `/prod`                 |
| **多租户架构**     | SaaS应用中，为不同客户分配独立vhost，实现数据隔离。                      | `/tenant_alibaba`, `/tenant_tencent`     |
| **命名空间**       | 资源（如队列名）只需在所属vhost内唯一，不同vhost可重名。 | `/app1/logs` 和 `/app2/logs` 可以共存且互不影响 |

默认情况下，RabbitMQ 自带一个名为 `/` 的 vhost。**强烈建议在生产环境中创建并使用新的 vhost**，而不是继续使用这个默认的 vhost，以避免潜在混淆。

### 🔧 管理 Vhost

管理 vhost 的常用方式有以下几种：

1.  **命令行工具 (`rabbitmqctl`)**: 最直接的方式，适合脚本化和服务器管理。
    ```bash
    # 创建 vhost
    rabbitmqctl add_vhost /your_vhost_name
    # 删除 vhost
    rabbitmqctl delete_vhost /your_vhost_name
    # 列出所有 vhost
    rabbitmqctl list_vhosts
    ```
    创建后通常需为用户授权：
    ```bash
    # 授予用户 alice 对 vhost /your_vhost_name 的所有操作权限
    rabbitmqctl set_permissions -p /your_vhost_name alice ".*" ".*" ".*"
    ```


2.  **Web 管理界面**: 通过浏览器访问 RabbitMQ 的 Web 管理界面（默认端口 `15672`），在 **Admin** -> **Virtual Hosts** 标签页中，可以直观地创建、删除 vhost 以及管理其权限。

3.  **HTTP API**: 通过调用 RabbitMQ 提供的 HTTP API 管理 vhost，便于自动化集成。

### 📌 客户端连接指定 Vhost

生产者和消费者在连接 RabbitMQ 时，**必须指定要使用的 vhost**（如果使用默认的 `/`，有时客户端库可能允许省略，但显式指定是好习惯）。

以下是不同语言的连接示例：

-   **Java (使用 amqp-client)**:
    ```java
    ConnectionFactory factory = new ConnectionFactory();
    factory.setHost("localhost");
    factory.setVirtualHost("/your_vhost_name"); // 指定 vhost
    factory.setUsername("your_username");
    factory.setPassword("your_password");
    Connection connection = factory.newConnection();
    ```



### 💡 最佳实践与注意事项

*   **清晰的命名**：为vhost起一个有意义的名字，如按项目`/project-x`、按环境`/prod`、按团队`/team-data`。
*   **权限最小化原则**：遵循**最小权限原则**，只授予用户必要的权限。
*   **区分环境**：为开发、测试、生产等不同环境创建不同的vhost，并确保应用程序连接配置正确，避免误操作。
*   **监控与清理**：定期监控各个vhost的资源使用情况（连接数、队列数、消息速率等），并清理不再使用的vhost。

### ⚠️ 需要注意的要点

-   **vhost 不直接存储消息**：消息存储在队列中，而队列属于特定的 vhost。
-   **连接必须指定 vhost**：客户端连接时必须指定一个已存在且有权限的 vhost，否则连接会失败。
-   **默认 vhost 的风险**：生产环境中建议避免使用默认的 `/` vhost，并为不同应用或环境创建独立的 vhost，**严禁不同环境共用同一 vhost**。
-   **权限是关键**：vhost的隔离安全性严重依赖于正确的用户和权限设置。

- rabbit mq 与kefka 对比优劣势？

- kafka 消费端如何保证数据一致性？
    - 1.ISR（同步副本集）：每个分区维护一个与 Leader 同步的副本列表，只有 ISR 中的副本才被视为有效备份。当生产者设置 acks=all 时，消息需被所有 ISR 副本写入后才确认成功，确保数据不丢失
    - 2.幂等性处理
    - 3.原子提交：通过 Kafka 事务将消息处理与偏移量提交绑定，确保二者要么同时成功，要么回滚。
    - 4.kafka 默认是异步提交，异步提交会丢失数据； 
    - 同步提交：在消息处理完成后调用 **consumer.commitSync()**，确保偏移量提交成功。适合对一致性要求高的场景


## 数据库

## MySQL一张数据量很大的表如何优化查询速度？

### 核心思路
优化的核心思路可以归纳为以下几点：
1.  **减少数据量**：让数据库引擎需要扫描和计算的数据尽可能的少。
2.  **减少计算量**：优化查询逻辑，避免复杂的计算和临时表。
3.  **转换思路**：用空间换时间，通过增加硬件资源或冗余数据来提升速度。
4.  **终极方案**：当单表优化到极限时，必须进行架构上的拆分。

---

### 一、 基础且高效的优化（首选方案）

这些方法成本低、见效快，应优先考虑。

#### 1. 优化索引 (Index Optimization)
索引是优化查询最直接有效的手段。

*   **确保查询使用了合适的索引**： 使用 `EXPLAIN` 命令分析你的慢查询，查看是否使用了索引，以及使用的是哪个索引。
    ```sql
    EXPLAIN SELECT * FROM your_large_table WHERE some_column = 'value';
    ```
    关注 `key`（使用的索引）、`rows`（预估扫描行数）、`type`（访问类型，`const`, `ref`, `range` 为佳，`ALL` 为全表扫描需避免）。

*   **为 `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY` 子句中的列创建索引**。

*   **避免冗余和未使用的索引**： 索引会降低写操作（INSERT/UPDATE/DELETE）的速度并占用空间。定期检查并删除未使用的索引。

*   **使用覆盖索引 (Covering Index)**： 如果索引包含了查询所需要的所有字段，MySQL就可以直接从索引中获取数据，而不需要回表查询数据行，效率极高。
    *   **坏**：`SELECT * FROM table WHERE indexed_column = 'value’;` (需要回表)
    *   **好**：`SELECT indexed_column, other_indexed_column FROM table WHERE indexed_column = 'value’;` (可能覆盖索引)

*   **注意索引的选择性**： 为选择性高的列创建索引效果更好（例如，身份证号、用户名）。选择性低的列（如：性别、状态标志）加索引效果不大，有时反而更差。

*   **前缀索引 (Prefix Indexes)**： 对于 TEXT/BLOB 或很长的 VARCHAR 列，可以只对列的前 N 个字符创建索引，节省空间。
    ```sql
    CREATE INDEX idx_name ON your_table (long_column_name(255));
    ```

#### 2. 优化SQL查询语句 (Query Optimization)
很多时候，慢查询是因为SQL写得不好。

*   **只获取需要的列**： 坚决避免 `SELECT *`，尤其是表中有TEXT/BLOB等大字段时。明确指定需要的列。
*   **使用高效的查询条件**：
    *   避免在 WHERE 子句中对字段进行函数操作（如 `WHERE YEAR(create_time) = 2023`），这会导致索引失效。应改为范围查询（`WHERE create_time BETWEEN '2023-01-01' AND '2023-12-31'`）。
    *   小心使用 `OR`，可能导致全表扫描。可以考虑用 `UNION` 替代。
    *   避免使用 `!=` 或 `NOT IN`，它们通常无法使用索引。
*   **优化联表查询 (JOIN)**：
    *   确保 `ON` 或 `USING` 子句中的列上有索引。
    *   被驱动表（第二个表）的连接列必须有索引。
    *   小表驱动大表。

---

### 二、 中级优化（表结构和系统层面）

当基础优化做到极致后，可以考虑这些方案。

#### 1. 分区表 (Partitioning)
将一张大表在物理上分割成多个更小的、更易管理的部分（分区），但对应用来说仍然是一张逻辑表。

*   **适用场景**： 数据有明显的逻辑区间，比如按时间（年/月）、地域范围等。常用于日志表、历史订单表。
*   **优点**： 查询时，优化器可以自动只扫描所需的分区（**分区裁剪**），极大减少扫描数据量。
*   **缺点**： 对业务透明，但管理复杂，且有很多限制（如所有分区必须使用相同的存储引擎、主键/唯一索引必须包含分区键）。
*   **示例**：
    ```sql
    CREATE TABLE sales (
        id INT NOT NULL,
        purchase_date DATE NOT NULL
    )
    PARTITION BY RANGE(YEAR(purchase_date)) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN (2010),
        PARTITION p3 VALUES LESS THAN (2020),
        PARTITION p4 VALUES LESS THAN MAXVALUE
    );
    -- 查询2023年的数据，只会扫描2023年所在的分区
    SELECT * FROM sales WHERE purchase_date BETWEEN '2023-01-01' AND '2023-12-31';
    ```

#### 2. 使用更快的存储设备
**将数据库放在SSD硬盘上**。IO瓶颈往往是数据库性能的最大杀手，SSD的随机读写能力远超机械硬盘，能极大提升查询和更新速度。

#### 3. 调整服务器参数 (Configuration Tuning)
优化MySQL的配置参数（`my.cnf` / `my.ini`），这对性能提升也很关键。

*   **`innodb_buffer_pool_size`**： **这是最重要的参数**。InnoDB缓冲池用于缓存表数据和索引。建议设置为可用物理内存的 **70%-80%**。让热数据尽可能留在内存中。
*   **`innodb_buffer_pool_instances`**： 如果缓冲池很大（比如 > 16GB），可以设置多个实例来减少锁竞争。
*   **`max_connections`**： 合理设置最大连接数，避免过多连接耗尽资源。
*   **`query_cache_size`**： **注意：在MySQL 5.7.20开始已弃用，8.0中已移除**。如果你的版本较早，可以考虑是否启用查询缓存，但对于写频繁的应用，查询缓存可能弊大于利。

**警告**： 不要盲目修改参数，最好参考官方文档或使用像 `MySQLTuner` 这样的工具来分析当前配置。

---

### 三、 高级/架构优化（应对海量数据）

当单表优化到极限，数据量持续增长时，必须从架构上动刀。

#### 1. 读写分离 (Read/Write Splitting)
*   **主从复制 (Master-Slave Replication)**： 搭建一个主库（Master）负责处理写操作（INSERT/UPDATE/DELETE），多个从库（Slave）通过复制同步主库的数据，负责处理读操作（SELECT）。
*   **优点**： 分摊数据库压力，提升读性能。从库还可以用于备份和数据分析，不影响主库。
*   **缺点**： 存在主从同步延迟，对数据一致性要求非常高的读操作可能需要读主库。

#### 2. 垂直拆分 (Vertical Sharding)
*   **做法**： 将一个包含很多字段的大表，按访问频度拆分成多个小表（例如，将常用的主字段放在一个表，将不常用的大字段如`TEXT`、`BLOB`放到另一个扩展表）。
*   **优点**： 使得核心查询需要扫描的数据页更少，IO效率更高。
*   **缺点**： 应用层需要做相应修改，查询时需要联表。

#### 3. 水平拆分/分库分表 (Horizontal Sharding)
这是处理亿级以上数据的终极大招。

*   **做法**： 将一张表的数据**按某种规则（分片键）** 分散到多个数据库或多个数据表中。例如，按用户ID哈希取模，或按时间范围。
*   **优点**： 从根本上解决了单表、单库的性能瓶颈和容量上限问题。
*   **缺点**：
    *   **复杂度极高**： 应用层需要大幅修改，需要中间件（如 ShardingSphere, MyCat, Vitess）来管理分片路由。
    *   跨分片查询、聚合、排序、事务变得非常复杂和困难。
    *   扩容（如增加分片数量）操作繁琐。

**常见的分片策略**：
*   **范围分片**： 按时间或ID范围（如1-100万在表1，100万-200万在表2）。容易产生热点数据。
*   **哈希分片**： 对分片键（如`user_id`）进行哈希取模，均匀分布数据。扩容时数据迁移量大。
*   **地理位置分片**： 根据用户地域分到不同的数据库。

---

### 总结与操作流程

当你面对一张大表时，建议按以下步骤进行排查和优化：

1.  **定位问题**： 使用**慢查询日志 (Slow Query Log)** 找出最耗时的SQL。
2.  **分析SQL**： 对慢SQL使用 **`EXPLAIN`** 命令，分析其执行计划，看是否索引失效、是否全表扫描。
3.  **优化索引**： 根据 `EXPLAIN` 的结果，添加或调整索引。这是最快的方法。
4.  **优化SQL**： 重写SQL，避免 `SELECT *`，避免在WHERE子句中使用函数等。
5.  **考虑分区**： 如果数据有明显的冷热特性（如时间），考虑使用分区表。
6.  **调整配置**： 优化 `innodb_buffer_pool_size` 等核心参数。
7.  **硬件升级**： 使用SSD硬盘，增加内存。
8.  **架构升级**： 如果以上所有方法都无法满足需求，再考虑**读写分离**和**分库分表**这些重量级方案。


## NOSQL

- 你们经常用的NoSQL数据库有哪些？

## 运维Linux相关
 - docker file 会写吗？
 - 常见Linux命令
 - Spring boot jar包 启动命令行
 - 服务报警你们是如何做的，如何处理？

### 前端 
- vue 生命周期函数有哪些？
> 1. 创建阶段
     beforeCreate（选项式 API）
     触发时机：组件实例初始化后，数据观测和事件配置前。
     用途：初始化非响应式数据或全局配置（如第三方库初始化）。
     组合式 API 替代：逻辑直接写在 setup 函数中。
     created（选项式 API）
     触发时机：实例创建完成，数据观测和事件初始化后。
     用途：访问组件数据、发送异步请求（如获取初始数据）。
     组合式 API 替代：逻辑直接写在 setup 函数中。
>2. 挂载阶段
   beforeMount（选项式 API）
   触发时机：模板编译完成，但未挂载到真实 DOM。
   用途：修改虚拟 DOM 或初始化非 DOM 资源。
   组合式 API：onBeforeMount（需从 vue 导入）。
   mounted（选项式 API）
   触发时机：组件挂载到 DOM 后，可安全访问真实 DOM。
   用途：操作 DOM（如初始化图表库）、发送依赖 DOM 的异步请求。
   组合式 API：onMounted（示例见下方代码）。
>3. 更新阶段
   beforeUpdate（选项式 API）
   触发时机：响应式数据变化，虚拟 DOM 重新渲染前。
   用途：获取更新前的状态（如滚动位置），避免在此阶段修改数据。
   组合式 API：onBeforeUpdate。
   updated（选项式 API）
   触发时机：数据和 DOM 更新完成后。
   用途：依赖最新 DOM 状态的操作（如调整布局），避免在此修改数据导致循环更新。
   组合式 API：onUpdated。
>4. 卸载阶段
   beforeUnmount（选项式 API，替代 Vue 2 的 beforeDestroy）
   触发时机：组件卸载前，DOM 仍存在。
   用途：清理定时器、解绑事件监听、取消网络请求等资源释放操作。
   组合式 API：onBeforeUnmount。
   unmounted（选项式 API，替代 Vue 2 的 destroyed）
   触发时机：组件卸载后，所有指令和事件监听器已解绑。
   用途：执行最终清理（如日志记录），此时无法访问组件实例。
   组合式 API：onUnmounted。

# vivo 外包 2025-9-9

### 离职原因

## 平常如何学习的？

## 数据库相关

## 说一下SQL执行流程

## 了解MySQL索引吗？说一下B+索引，叶子节点存放了几条数据？

## 你知不知道MVCC特性？

## 你在华为有没有遇到慢SQL，是如何优化的？

## Java核心

## jvm 如何计算实例对象占用内存的？

## new一个对象，对象的运行流程？

## redis

## 有没有用到redis，你们都是用在什么场景？

- redis String 内部是如何实现的？


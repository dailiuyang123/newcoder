# 2025 校招/社招 Java 八股文面试题库，横扫大厂后端岗
2025-06-11 00:00:00

## 前言
再过2个月即将进入9月，然而面对今年的大环境，跳槽成功的难度比往年高了很多。明显能感受到，今年Java开发从业者跳槽面试时，无论一面还是二面，都开始着重考验技术功底和基础，对源码解读与核心原理的理解也成了加分项。尤其对于那些对Java核心基础知识点掌握不扎实、缺乏体系化认知的朋友来说，面试更是一大难题。

无论是校招还是社招，都离不开各种面试与笔试，如何准备这些环节就显得格外重要。其实，笔试和面试并非无章可循，这里的“有章可循”是指技术面试可以提前准备，但我非常不认同临近考试才靠死记硬背题目来应对的方式，这种方法过于极端，而且在有经验的面试官面前根本不起作用。建议大家还是一步一个脚印，踏踏实实地夯实基础。

今天在此分享国内公司Java面试中常问的问题，涵盖JVM、常用算法与数据结构、Redis缓存、分布式、Spring、微服务等领域。正所谓知己知彼，只有巩固好体系化知识，才能在面对不断更新的技术时快速掌握，同时在面试和工作中脱颖而出！

涉及核心技术领域：Java集合、JVM、并发编程、Spring、MyBatis、SpringMVC、微服务、Dubbo、Netty、网络、Zookeeper、Kafka、RabbitMQ、Redis缓存、数据库、设计模式


## 一、微服务与Hystrix核心问题
在微服务架构中，若上图中的微服务9发生故障，使用传统方法会传播异常，仍可能导致整个系统崩溃。随着微服务数量增加（最多可达1000个），该问题会愈发复杂，这正是Hystrix出现的原因——我们可利用Hystrix的Fallback（降级）方法功能应对此类情况。

以简化场景为例：存在`employee-consumer`（服务消费者）和`employee-producer`（服务生产者），`employee-consumer`调用`employee-producer`提供的服务。假设因某种原因，`employee-producer`提供的服务抛出异常，此时通过Hystrix定义降级方法，若服务调用发生异常，降级方法会返回默认值，避免故障扩散。

### 关键问题：什么是Hystrix断路器？我们需要它吗？
1. **定义**：当`firstPageMethod()`中的异常持续发生时，Hystrix断路器会触发“熔断”状态。此时`employee-consumer`会直接跳过`firstPageMethod()`，转而调用降级方法，不再尝试调用故障服务。
2. **核心作用**：为故障服务（如`firstPageMethod()`及其依赖的其他方法）留出恢复时间。在负载较低的场景下，导致异常的问题有更高的概率自行恢复，从而避免故障在微服务集群中蔓延，保障系统整体可用性。
3. **必要性**：在微服务架构中，服务间依赖关系复杂，单个服务故障可能引发“雪崩效应”。Hystrix断路器通过熔断、降级机制，有效隔离故障服务，是保障分布式系统稳定性的关键组件，因此必须使用。


## 二、1000道高频Java体系面试题（分领域整理）
### （一）Java集合（22题）
1. ArrayList 和 Vector 的区别。
2. 说说 ArrayList、Vector、LinkedList 的存储性能和特性。
3. 快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？
4. HashMap 的数据结构。
5. HashMap 的工作原理是什么?
6. HashMap 什么时候进行扩容呢？
7. List、Map、Set 三个接口，存取元素时，各有什么特点？
8. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?
9. 两个对象值相同（x.equals(y) == true），但却可有不同的 hash code，这句话对不对?
10. heap 和 stack 有什么区别。
11. Java 集合类框架的基本接口有哪些？
12. HashSet 和 TreeSet 有什么区别？
13. HashSet 的底层实现是什么?
14. LinkedHashMap 的实现原理?
15. 为什么集合类没有实现 Cloneable 和 Serializable 接口？
16. 什么是迭代器（Iterator）？
17. Iterator 和 ListIterator 的区别是什么？
18. 数组（Array）和列表（ArrayList）有什么区别？什么时候应该使用 Array 而不是 ArrayList？
19. Java 集合类框架的最佳实践有哪些？
20. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？
21. Comparable 和 Comparator 接口是干什么的？列出它们的区别
22. Collection 和 Collections 的区别。

### （二）JVM与调优（21题）
1. Java 类加载过程？
2. 描述一下 JVM 加载 Class 文件的原理机制?
3. Java 内存分配。
4. GC 是什么? 为什么要有 GC？
5. 简述 Java 垃圾回收机制
6. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）
7. 垃圾回收的优点和原理，并考虑 2 种回收机制
8. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
9. Java 中会存在内存泄漏吗，请简单描述
10. 深拷贝和浅拷贝。
11. System.gc() 和 Runtime.gc() 会做什么事情？
12. finalize() 方法什么时候被调用？析构函数（finalization）的目的是什么？
13. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？
14. 什么是分布式垃圾回收（DGC）？它是如何工作的？
15. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
16. 在 Java 中，对象什么时候可以被垃圾回收？
17. 简述 Java 内存分配与回收策略以及 Minor GC 和 Major GC。
18. JVM 的永久代中会发生垃圾回收么？
19. Java 中垃圾收集的方法有哪些？
20. 什么是类加载器，类加载器有哪些？
21. 类加载器双亲委派模型机制？

### （三）并发编程（28题）
1. Synchronized 用过吗，其原理是什么？
2. 你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？
3. 什么是可重入性，为什么说 Synchronized 是可重入锁？
4. JVM 对 Java 的原生锁做了哪些优化？
5. 为什么说 Synchronized 是非公平锁？
6. 什么是锁消除和锁粗化？
7. 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？
8. 乐观锁一定就是好的吗？
9. 跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？
10. 那么请谈谈 AQS 框架是怎么回事儿？
11. 请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。
12. ReentrantLock 是如何实现可重入性的？
13. 除了 ReentrantLock，你还接触过 JUC 中的哪些并发工具？
14. 请谈谈 ReadWriteLock 和 StampedLock。
15. 如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。
16. CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？
17. Java 线程池相关问题：Java 中的线程池是如何实现的？
18. 创建线程池的几个核心构造参数？
19. 线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？
20. 既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同
21. 如何在 Java 线程池中提交线程？
22. 什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？
23. 请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？
24. 既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？
25. 请对比下 volatile 对比 Synchronized 的异同。
26. 请谈谈 ThreadLocal 是怎么解决并发安全的？
27. 很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？

### （四）Spring（25题）
1. 什么是Spring 框架?Spring 框架有哪些主要模块?
2. 使用Spring 框架能带来哪些好处?
3. 什么是控制反转(IOC) ?什么是依赖注入?
4. 请解释下Spring 框架中的 IoC?
5. BeanFactory 和 ApplicationContext有什么区别?
6. Spring 有几种配置方式?
7. 如何用基于XML配置的方式配置 Spring?
8. 如何用基于Java配置的方式配置Spring?
9. 怎样用注解的方式配置Spring?
10. 请解释Spring Bean 的生命周期?
11. Spring Bean 的作用域之间有什么区别?
12. 什么是 Spring inner beans?
13. Spring 框架中的单例Beans是线程安全的么?
14. 请举例说明如何在 Spring 中注入一个Java Collection?
15. 如何向 Spring Bean 中注入一个Java.util.Properties?
16. 请解释Spring Bean的自动装配?
17. 请解释自动装配模式的区别?
18. 如何开启基于注解的自动装配?
19. 请举例解释@Required注解?
20. 请举例解释@Autowired注解?
21. 构造方法注入和设值注入有什么区别?
22. Spring 框架中有哪些不同类型的事件?
23. FileSystemResource 和 ClassPathResource有何区别?
24. Spring 框架中都用到了哪些设计模式?

### （五）微服务（58题：SpringBoot、SpringCloud、Dubbo）
#### 1. Spring Boot（20题）
1. 什么是 Spring Boot?
2. Spring Boot有哪些优点?
3. Spring Boot的核心配置文件有哪几个?它们的区别是什么?
4. Spring Boot的配置文件有哪几种格式?它们有什么区别?
5. Spring Boot的核心注解是哪个?它主要由哪几个注解组成的?
6. 开启Spring Boot特性有哪几种方式?
7. Spring Boot需要独立的容器运行吗?
8. 运行 Spring Boot有哪几种方式?
9. Spring Boot自动配置原理是什么?
10. Spring Boot2.X有什么新特性?与1.X有什么区别?
11. 如何使用Spring Boot实现分页和排序?
12. 如何实现Spring Boot应用程序的安全性?
13. 如何集成Spring Boot和ActiveMQ?
14. 什么是YAML?
15. Spring Boot中的监视器是什么?
16. 什么是Swagger?你用Spring Boot实现了它吗?
17. 如何使用Spring Boot实现异常处理?
18. RequestMapping 和 GetMapping 的不同之处在哪里?
19. Spring Boot可以兼容老Spring 项目吗,如何做?
20. 保护Spring Boot 应用有哪些方法?

#### 2. Spring Cloud（8题）
1. 什么是Spring Cloud?
2. 使用Spring Cloud有什么优势?
3. 服务注册和发现是什么意思?Spring Cloud如何实现?
4. 负载平衡的意义什么?
5. 什么是Hystrix?它如何实现容错?
6. 什么是Hystrix断路器?我们需要它吗?
7. 什么是Netflix Feign?它的优点是什么?
8. 什么是Spring Cloud Bus?我们需要它吗?

#### 3. Dubbo（17题）
1. 为什么要用Dubbo?
2. Dubbo 的整体构设计有哪些分层?
3. 默认使用的是什么通信框架,还有别的选择吗?
4. 服务调用是阻塞的吗?
5. 一般使用什么注册中心?还有别的选择吗?
6. 默认使用什么序列化框架,你知道的还有哪些?
7. 服务提供者能实现失效剔除是什么原理?
8. 服务上线怎么不影响旧版本?
9. 如何解决服务调用链过长的问题?
10. 说说核心的配置有哪些?
11. Dubbo推荐用什么协议?
12. 同一个服务多个注册的情况下可以直连某一个服务吗?
13. 画一画服务注册与发现的流程图?
14. Dubbo 集群容错有几种方案?
15. Dubbo 服务降级,失败重试怎么做?
16. Dubbo使用过程中都遇到了些什么问题?
17. Dubbo Monitor实现原理?

### （六）Netty（10题）
1. BIO、NIO 和 AIO 的区别？
2. NIO 的组成？
3. Netty 的特点？
4. Netty 的线程模型？
5. TCP 粘包/拆包的原因及解决方法？
6. 了解哪几种序列化协议？
7. 如何选择序列化协议？
8. Netty 的零拷贝实现？
9. Netty 的高性能表现在哪些方面？
10. NIOEventLoopGroup 源码？

### （七）网络（7题）
1. 网络7层架构
2. TCP/IP 原理
3. TCP 三次握手/四次挥手
4. HTTP 原理
5. 传输流程
6. HTTP 状态
7. CDN 原理

### （八）Redis（16题）
1. 什么是 redis?
2. Redis 的特点
3. Redis 支持的数据类型
 > 答案: redis 常见的数据类型有：字符串(String)、列表(list)、集合(set)、有序集合(sort set)、哈希(hash)、位图(bit map)、 HyperLogLog、 地理位置。
4. Redis 是单进程单线程的
  > 答案：单进程。多线程的，像 RDB,AOP，异步删除，集群同步 是后台开启新线程处理的。
9. Redis 的回收策略

13. MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？

1、什么是 Redis?

2、Redis 的数据类型？

3、使用 Redis 有哪些好处？

4、Redis 相比 Memcached 有哪些优势？

5、Memcache 与 Redis 的区别都有哪些？

6、Redis 是单进程单线程的？

7、一个字符串类型的值能存储最大容量是多少？

8、Redis 的持久化机制是什么？各自的优缺点？

9、Redis 常见性能问题和解决方案：

10、redis 过期键的删除策略？

11、Redis 的回收策略（淘汰策略）?

> 答案：
以下是Redis内存淘汰策略的汇总表格，按策略类型分类展示：

| 策略类型         | 策略名称           | 淘汰规则                                                                 | 适用场景                                                                 |
|------------------|--------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 不淘汰数据       | noeviction         | 内存满时拒绝新写入，不淘汰任何数据，返回OOM错误                          | 不允许数据丢失的核心业务（如分布式锁、关键状态存储），需确保内存充足       |
| 从所有键中淘汰   | allkeys-lru        | 淘汰所有键中「最近最少使用（LRU）」的键                                  | 存在明显热点数据（如电商商品详情、高频访问内容），热点随时间变化           |
| 从所有键中淘汰   | allkeys-lfu        | 淘汰所有键中「最不经常使用（LFU）」的键                                  | 热点相对稳定（如长期畅销商品），需区分访问频率的场景                       |
| 从所有键中淘汰   | allkeys-random     | 随机淘汰所有键中的任意键                                                | 数据访问分布均匀，无明显热点（如随机访问的日志数据）                       |
| 仅从过期键中淘汰 | volatile-lru       | 从设置了过期时间的键中，淘汰「最近最少使用（LRU）」的键                  | 需保护未设过期时间的核心数据，仅淘汰临时过期数据（如用户会话）             |
| 仅从过期键中淘汰 | volatile-lfu       | 从设置了过期时间的键中，淘汰「最不经常使用（LFU）」的键                  | 临时数据有访问频率差异，需保留高频访问的临时数据（如短期活动缓存）         |
| 仅从过期键中淘汰 | volatile-random    | 从设置了过期时间的键中，随机淘汰任意键                                  | 临时数据价值均等，无需区分访问模式（如随机生成的短期令牌）                 |
| 仅从过期键中淘汰 | volatile-ttl       | 从设置了过期时间的键中，淘汰「剩余过期时间最短（TTL）」的键              | 希望优先保留较晚过期的临时数据（如即将失效的验证码、短期有效缓存）         |

表格说明：
- LRU（Least Recently Used）：基于「最后访问时间」，淘汰最久未被访问的键
- LFU（Least Frequently Used）：基于「访问频率」，淘汰总访问次数最少的键
- TTL（Time To Live）：基于「剩余存活时间」，淘汰最快过期的键

12、为什么 redis 需要把所有数据放到内存中？

13、Redis的同步机制了解么？

>  答案：Redis 的主从复制通过 全量同步 和 增量同步 实现数据一致性
>  - 全量同步触发的条件是：：从节点首次连接、数据丢失或配置变更（如 SLAVEOF 命令）。
>    - 从节点发送 PSYNC ? -1 请求，主节点生成 RDB 快照并记录期间的写命令
>    - 主节点发送 RDB 文件到从节点，从节点清空旧数据并加载 RDB
>    - 主节点补发 RDB 生成期间的增量命令，确保数据完整
>  - 增量同步触发的条件是:从节点短时间断连后重连（复制偏移量未超出积压缓冲区）。
>    - 复制积压缓冲区（repl-backlog）：主节点维护的环形缓冲区，默认大小 1MB，记录最近的写操作。
>    - 复制偏移量（offset）：主从节点通过 offset 标识数据同步进度，若从节点 offset 在缓冲区范围内，则仅同步缺失部分
>  - 混合持久化
>    - 主节点开启rdb和aof，从节点仅开启RDB以减少磁盘IO

14、Pipeline 有什么好处，为什么要用 pipeline？

> 答案：pipeline 是一种优化Redis性能的策略，它可以将多个命令组合在一起发送给Redis服务器，从而提高性能。
 

15、是否使用过 Redis 集群，集群的原理是什么？

16、Redis 集群方案什么情况下会导致整个集群不可用？

17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？

> 答案：Jedis 与 Redisson

18、Jedis 与 Redisson 对比有什么优缺点？

> 答案：Redisson 和 Jedis 都是 Java 生态中操作 Redis 的常用客户端，但它们的设计理念和功能定位有较大差异，适用于不同场景：

### **1. 核心定位**
- **Jedis**  
  是 Redis 官方推荐的 Java 客户端之一，定位为 **轻量级、低封装的 Redis 命令映射工具**。  
  它直接对应 Redis 底层命令（如 `set()`、`get()`、`hset()` 等），API 设计简洁，几乎是 Redis 命令的一对一翻译。

- **Redisson**  
  是一个 **基于 Redis 的分布式框架**，不仅提供 Redis 命令操作，更封装了大量分布式场景下的高级功能（如分布式锁、分布式集合、分布式对象等）。  
  它的 API 设计更贴近 Java 开发者习惯，提供了许多开箱即用的分布式工具类。


### **2. 核心差异**

| **维度**         | **Jedis**                              | **Redisson**                          |
|------------------|----------------------------------------|---------------------------------------|
| **API 风格**     | 命令式（与 Redis 命令高度一致）        | 面向对象（封装为 Java 类和方法）      |
| **连接模型**     | 基于 BIO（阻塞 IO），单连接线程安全问题需自行处理（通常用连接池） | 基于 NIO（非阻塞 IO），内部实现连接池和线程安全 |
| **功能范围**     | 仅实现 Redis 基础命令                   | 除基础命令外，提供丰富的分布式功能     |
| **易用性**       | 需手动处理序列化、分布式锁等细节        | 内置序列化、自动处理分布式场景细节     |
| **性能**         | 简单命令执行效率高，但复杂场景需自行优化 | 复杂场景下性能更稳定，优化更全面       |


### **3. 典型功能对比**
- **基础 Redis 操作**  
  两者都能完成，但 Jedis 更直接（如 `jedis.set("key", "value")`），Redisson 需通过 `RBucket` 等对象（如 `redisson.getBucket("key").set("value")`）。

- **分布式锁**
    - Jedis：需手动实现（如用 `setNx` + 过期时间 + Lua 脚本），容易出错。
    - Redisson：内置 `RLock` 接口，一行代码即可实现可靠的分布式锁（支持自动续期、可重入、公平锁等）：
      ```java
      RLock lock = redisson.getLock("myLock");
      lock.lock();  // 获取锁
      try {
          // 业务逻辑
      } finally {
          lock.unlock();  // 释放锁
      }
      ```

- **其他分布式功能**  
  Redisson 还提供：
    - 分布式集合（`RMap`、`RList`、`RSet` 等，支持分布式操作）
    - 分布式信号量（`RSemaphore`）、闭锁（`RLatch`）
    - 发布订阅、延迟队列、布隆过滤器等  
      这些功能在 Jedis 中需手动实现，复杂度高。


### **4. 适用场景**
- **选 Jedis 当**：
    - 需求简单，仅需执行基础 Redis 命令
    - 追求极致轻量化，避免引入额外依赖
    - 对 Redis 命令熟悉，希望直接控制底层操作

- **选 Redisson 当**：
    - 涉及分布式场景（如分布式锁、分布式集合）
    - 希望减少重复开发（如无需手动实现锁续期、序列化）
    - 更关注开发效率和代码可读性
    - 需要处理复杂的 Redis 高级功能


### **5. 总结**
- Jedis 是「Redis 命令的 Java 映射器」，适合简单场景和对底层有强控制需求的场景。
- Redisson 是「基于 Redis 的分布式开发框架」，适合分布式系统，简化复杂功能的实现。

实际项目中，两者也可共存：用 Redisson 处理分布式逻辑，用 Jedis 处理简单命令（但需注意连接池管理）。

19、Redis 如何设置密码及验证密码？

20、说说Redis哈希槽的概念？
> 答案：Redis 哈希槽（Hash Slot）是 Redis 集群实现数据分片的核心机制，它通过将键值数据均匀分布到多个节点，解决了单机存储瓶颈和水平扩展问题。
> - 数据分片：将键映射到不同槽，再由不同节点负责处理这些槽。
> - 负载均衡：确保数据均匀分布，避免单节点压力过大。

21、Redis 集群的主从复制模型是怎样的？

22、Redis 集群会有写操作丢失吗？为什么？

23、Redis 集群之间是如何复制的？

24、Redis 集群最大节点个数是多少？

> 答案：redis 集群最大节点个数是 16384

25、Redis 集群如何选择数据库？



26、怎么测试 Redis 的连通性？

27、怎么理解 Redis 事务？

28、Redis 事务相关的命令有哪几个？

29、Redis key 的过期时间和永久有效分别怎么设置？

30、Redis 如何做内存优化？

31、Redis 回收进程如何工作的？

32、都有哪些办法可以降低 Redis 的内存使用情况呢？

33、Redis 的内存用完了会发生什么？

> 答案：

34、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set 他们最多能存放多少元素？

> 答案：Redis 是内存数据库，所有 key 和 value 均存储在内存中。实际存储量计算公式为：
\(\text{理论存储量} = \frac{\text{可用内存}}{\text{单个key的平均内存占用}}\)示例估算：
假设每个 key 平均占用 100 字节（含元数据和 value），则：1GB 内存 ≈ 1000 万个 key8GB 内存 ≈ 8000 万个 key
若 value 较大（如每个 key 对应 1KB 数据），存储量将骤降至 百万级38。内存配置参数：
通过 maxmemory 可限制 Redis 内存使用（如 maxmemory 2gb），达到阈值时触发淘汰策略（如 LRU）1314。

35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证
redis 中的数据都是热点数据？

> 答案: 利用redis的内存淘汰策略（LRU/LFU）
> 1. 计算出20w的key所占内存大小，并计算出20w的key所占内存大小所占的磁盘空间大小
> 2. 根据内存大小，设置：maxmemory，设置maxmemory-policy为volatile-lru
> 3. **缓存预热：初始加载历史热点数据，若缓存为空，大量请求会直接访问数据库，出现缓存穿透**
> 4. 
36、Redis 最适合的场景？

37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？

> 答案：应急场景（已存在 1 亿 key）：必须用 **SCAN命令** ，设置合理的count参数，客户端处理游标和去重，低峰期执行；
规划场景（新业务设计）：优先用 Hash/Sorted Set 集中存储特定前缀的 key，彻底规避遍历操作，兼顾性能与可维护性；
绝对禁止：生产环境绝不使用**KEYS命令**，避免业务阻塞。

38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？
> 答案：防止缓存雪崩

39、使用过 Redis 做异步队列么，你是怎么用的？

40、使用过 Redis 分布式锁么，它是什么回事？

> 答案 : 
> 通过 setNx  实现分布式锁，有以下3个问题
 - **1**. 如果获得锁的线程被中断，或者报错，导致锁无法释放，那么锁将无法被其他线程获取。
> 解决方案： 设置过期时间，``` SET lock_key "value" NX PX 30000 ```
 - **2**. 线程删除其他线程设置的锁： 
   - **2.1** 锁释放 “误删” 风险： 锁的过期时间过短，如果线程执行过久，超过设置的过期时间，导致其他线程获取到锁，当前线程又删除了锁。
   - **2.2**  锁的提前过期，导致锁竞争，若持有锁的业务逻辑执行时间 超过 TTL 时长，锁会在业务未完成时自动过期，此时其他线程会 “误以为锁已释放” 而成功获锁，导致 多个线程同时持有同一把锁，引发数据竞争（如重复修改数据、脏读等）。

> 解决方案：锁的值设置为唯一标识（如 UUID），释放锁时先判断值是否匹配，再删除（需通过 Lua 脚本保证原子性）。
 - **3**. 锁的过期时间难以确定
> 解决方案：实现锁的「自动续期」（如 Redisson 中的「看门狗」机制）。

### （九）Zookeeper（23题）
1. ZooKeeper提供了什么?
2. Zookeeper文件系统
3. 四种类型的znode
4. Zookeeper通知机制
5. Zookeeper做了什么?
6. zk的命名服务(文件系统)
7. zk的配置管理(文件系统、通知机制)
8. Zookeeper集群管理(文件系统、通知机制)
9. Zookeeper分布式锁(文件系统、通知机制)
10. 获取分布式锁的流程
11. Zookeeper队列管理(文件系统、通知机制)
12. Zookeeper数据复制
13. Zookeeper工作原理
14. zookeeper是如何保证事务的顺序一致性的?
15. Zookeeper 下 Server工作状态
16. zookeeper是如何选取主leader的?
17. Zookeeper同步流程
18. 分布式通知和协调
19. 机器中为什么会有leader?
20. zk节点宕机如何处理?
21. zookeeper负载均衡和nginx负载均衡区别
22. zookeeper watch机制

### （十）Kafka（4题+核心设计）
#### 1. 高频问题
1. Kafka 概念
2. Kafka 数据存储设计
3. 生产者设计
4. 消费者设计

#### 2. 核心设计细节
- **数据文件索引**：采用“分段索引+稀疏存储”机制。Kafka为每个分段数据文件建立索引文件（扩展名为.index），未为每条Message建立索引，而是每隔一定字节数据建立一条索引，避免索引文件占用过多空间，确保可加载到内存。查找指定offset的Message时，可通过二分查找定位到对应的segment数据文件。
- **partition数据文件结构**：每条Message包含3个属性——offset（逻辑标识，唯一确定partition中的Message，非实际存储位置）、MessageSize（消息内容大小）、data（消息具体内容）。
- **数据文件分段（segment）**：partition物理上由多个等大的segment文件组成，采用顺序读写方式。每个segment文件以该段最小offset命名（扩展名为.log），例如`00000000000000368769.log`，便于快速定位。
- **生产者负载均衡**：partition会均衡分布到不同broker上，生产者可通过随机策略将消息分发到不同partition，充分利用broker集群性能，提高消息吞吐量。

### （十一）数据结构（核心知识点）
#### 1. 栈（stack）
- 定义：限制插入和删除仅在表的末端（栈顶，top）进行的线性表，遵循“后进先出（LIFO）”原则。